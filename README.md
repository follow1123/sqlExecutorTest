# sqlExecutorTest
一个动态生成SQL语句的小工具

> 在编写SunshineAirline项目时，编写一半业务后发现后端变得越来越臃肿，决定将后端进行优化，先从dao层开始，我的想法是将sql的联表查询语
> 句全部拆分，从而像出了一种方式，把所有表的mapper全部写成通用的增、删、改、查格式，自己编写一个数据库查询工具，把所有的mapper组织起
>来完成联表的操作

### 具体功能
* 使用java语法编写类似sql的语句并直接执行，工具动态生成sql语句，与mybatis结合执行，这个工具的本质就是一个动态生成sql语句的工具

* 语法：

  ```java
  SQL sql = new SQL();
  
  sql.select(all)
      .from(city)
      .where(equal(city.cityName, "Beijing",in(city.cityCode, "PEK", "……"))
      .executeQuery().forEach(System.out::println)
  ```
### 记录

#### 2020-11-8：
* 这个工具经过一个星期的完善大概成了这个结构，编写这个工具的原因主要是之前编写的项目里面的联查语句太多了，每个联查语句过于复杂而且还要
编写对应的对象，所以自己决定编写一个sql工具，主要是个sql语句的动态生成器，生成语句后再使用mybatis编写的通用查询语句进行查询，update、
insert、delete语句主要是上面的步骤，而select会单独优化，就是把联查语句拆分成一条一条的单表查询语句，再使用java的stream api对单表查询
的结果进行连接实现连表查询的效果（该功能还未实现）
* 今日实现功能：
    * 因为编写时没有上传git进行记录，所以大致理一下现在的进度。
    * 之前实现sql语句的动态生成器是使用一个StringBuilder不断的进行字符串连接，拼接sql语句达成动态sql的目的，但使用这种方式要实现的字
    符串拼接方法太多，到现在这个方式已经实现了，但感觉太过繁琐，比较臃肿，所以决定编写一个字符串模板引擎来实现动态生成sql语句，其实编写
    一个字符串模板引擎的想法我早就有了，在之前前端编写时就想实现一个，但前端页面要实现的零散功能太多太杂所以就没弄了，没弄后发现layui
    居然自带模板引擎，就打消了我自己实现的念头，现在动态生成sql又是一个类似的问题，所以这次会尝试这写一写，于是今天就写了一些，匹配语法
    主要用的的正则表达式，再慢慢解析，目前已经实现了一点，但还是有点bug，比如两个表达式不能连在一起写会拼接不上。但大致问题已解决。
* 在这个工具上传前我也想着要上传git进行记录，但发现构建初始结构的时候写的太烂了，上传了也没有意义，还有一方面原因是我这几天过度成迷于
编写某些问题的细节了，导致实现一个功能后跳出来一看发现根本没有意义，就推翻了重写，就浪费了大量时间，这几天也认识到了自己的一些问题，比较
喜欢过度专研某些细节，不知道这是好事好事坏事，反正就浪费了时间提升了编码能力。

#### 2020-11-09:
* 今天将自己实现的模板引擎优化了一定，还是有很多不足，将模板引擎写进sql动态生成工具内的时候我发现了一个问题，我已经忘记了最初实现这个
工具类的目的了，我要实现的功能是将联表查询拆分成多个单表查询，将这多个单表查询的结果根据关联使用java的stream api连接起来实现多表查询
的结果，要实现这个功能我就不能将sql语句写进mybatis的xml文件内，必须自己编写一个动态生成sql的工具，编写动态sql的工具类就必须使用
StringBuilder进行字符串拼接但这样拼接显得格外麻烦，所以我实现了一个模板引擎，但这个模板引擎因为能力问题只实现了最基础的功能，不能完全
代替StringBuilder的字符串拼接，我又要想办法将这两个方式融合，我现在就困在了这里，完全陷入了这个字符串拼接游戏内，而核心的功能都没实现
所以我必须要来跳出来看一看，我要根据我最初要实现的功再做分析。
  
### 2020-11-10:
* 今天思考了一下，因为模板引擎的功能不完善而且连拼接字符串的效率远低于StringBuilder就不用了，这个模板引擎的基础功能已经实现了，就算是
复习了下正则的语法，之间那个SQLStringUtil里面拼接字符串的方法太杂了，所以编写了一个StringUtil工具，将最基础的几个方法编写在这里，SQL
StringUtil就重写，重写了几个方法后发现我写的代码内有一类代码很冗余又很难分离，就是使用instanceof关键字时，如果匹配的话还要强转，所以
就写了个instanceof工具类，我真是工具狂魔，语法如下：
```java
    Instanceof ele = Instanceof.ele("123");

    ele.is(String.class, s -> {
        System.out.println("String => " + s);
    }).isArray(a -> {
        System.out.println("Array => " + a);
    }).isList(l -> {
        System.out.println("List => " + l);
    }).other(o -> {
        System.out.println("other => " + o);
    });
```
* 具体实现在那个类里的每个方法都有说明，今天收获很多。

### 2020-11-11:
* 今日实现功能：
    * 编写SQLStringUtil的拼接where后面条件的方法，根据操作符不同进行不同的拼接。优化InstanceOf工具类实现有返回值
    
### 2020-11-13：
* 今日实现功能：
    * 编写SQLStringUtil拼接查询参数的方法，尝试重写编写这个工具的传参模式。
* 今天在编写代码时终于深刻的理解了一把设计模式的重要性，之前在编写这个工具的传参模式的时候每个类之间的关系都是走一步看一步，只要能实现
就行，但到现在回看自己之前有多傻，果然有些东西你不自己实践实践是学不来的。

### 2020-11-19：
* 因为之前意识到自己设计的工具结构有问题，所以这几天就去看了看设计模式和一点多线程的东西，在看的设计模式的时候，有些模式感觉用过，只是
没有设计模式那么优雅而已，在看的时候，我就想到了我的代码里面的那些位置可以使用到这些，实在忍不住了就过来改代码了。
* 在设计StringUtil时，我用的是一个StringBuilder进行所有的字符串拼接操作，用完一次就把这个StringBuilder清空，但我的项目是web项目，是
多线程的，这种方式在多线程下会出很大的问题，所以我就开始想如可解决这个问题，开始想到的是将每个拼接字符串的方法加锁，当一个线程拼接完并
清空StringBuilder后就接着下一个，但这种方式想想效率就不行，所以目前想实现的方式是编写一个StringBuilderFactory专门获取StringBuilder
这个factory里面有一个StringBuilder数组，在多线程环境下，每个线程通过StringBuilderFactory获取StringBuilder对象时如果StringBuilder
数组内有空闲的StringBuilder时就返回空闲的，没有就创建一个并返回，这样每个线程的StringBuilder对象都不一样，就避免了后面出现的问题。
* 目前这个StringBuilderFactory已经编写了一点，在测试的时候 线程少的情况下可以达到理想的效果，但线程多了后就又乱了，目前我的还没学到
juc，这个factory尽量使用synchronized完成，锻炼锻炼我多线程和锁的能力，也为以后学juc做铺垫。

##3 2020-11-20：
* 今天继续编写StringBuilderFactory，在空闲的时候我就想，这个工厂在获取StringBuilder的时候是根据这个对象的长度是否为0判断这个对象是否
空闲的，但如果我在操作这个StringBuilder的时候刚好需要清空一下，而这个刚好被工厂判断为空闲又刚好是空闲数组的第一个那不就又出问题了，在
想到这个bug时我就立马想到了一个解决方案：使用适配器模式将StringBuilder适配一下不就行了，这样还可以把拼接sql所需要的StringBuilder的功
能就封装在这个适配器内，所以我就开始编写这个StringBuilderAdapter，StringBuilder对象使用构造器传入，在这个适配器内就可以判断是否可用
了，在编写完这个适配器类并运行后我突然发现居然把昨天线程多了后StringBuilder混乱的问题解决了，我都还没分析那个bug的原因就解决了，真是
惊喜。
* 编写完后我我做了如下几轮测试：
    * 模拟线程少的情况（通过）
    * 模拟线程多的情况（通过）
    * 模拟线程由少到多的情况（通过）
    * 模拟线程由多到少的情况（通过）
* 可以说是非常完美了，但我在测试模拟线程由多到少的情况想到了两个隐性的异常
    * 一个是在线程多的情况下，工厂里面的集合只会越来越大（表示对象创建的越来越多）需要编写一个自动清除里面对象的功能。
    * 第二个跟就是我在编写获取空闲的StringBuilder集合内的元素是只返回空闲集合内的第一个，第二个线程进来后也是同样的步骤，这样效率就非
    常低了，所以我就跟该了一下获取的步骤，在获取到空闲StringBuilder集合后后面的线程都根据一个index获取空闲的对象，这功能实现后我又测
    试了一下，感觉跟之前的方式没什么区别，创建的对象也是浮动的，这也可能是我编写的问题，